diff --git a/user-svc/pom.xml b/user-svc/pom.xml
index 5671b78..6b66e64 100644
--- a/user-svc/pom.xml
+++ b/user-svc/pom.xml
@@ -181,7 +181,12 @@
 			<artifactId>minio</artifactId>
 			<version>8.5.13</version>
 		</dependency>
-
+		<dependency>
+			<groupId>org.testcontainers</groupId>
+			<artifactId>minio</artifactId>
+			<version>1.20.0</version>
+			<scope>test</scope>
+		</dependency>
 	</dependencies>
 
 	<build>
diff --git a/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/account/AccountDto.java b/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/account/AccountDto.java
index 2490029..5ff2371 100755
--- a/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/account/AccountDto.java
+++ b/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/account/AccountDto.java
@@ -7,7 +7,8 @@ import java.util.Locale;
 import lombok.*;
 
 @Data
-@NoArgsConstructor
+@Builder
+@AllArgsConstructor
 public class AccountDto {
   @JsonProperty(access = JsonProperty.Access.READ_ONLY)
   private String accountId;
diff --git a/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/mapper/UserMapper.java b/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/mapper/UserMapper.java
index 86facbb..e5941d2 100755
--- a/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/mapper/UserMapper.java
+++ b/user-svc/src/main/java/com/github/ngodat0103/usersvc/dto/mapper/UserMapper.java
@@ -3,10 +3,12 @@ package com.github.ngodat0103.usersvc.dto.mapper;
 import com.github.ngodat0103.usersvc.dto.account.AccountDto;
 import com.github.ngodat0103.usersvc.persistence.document.Account;
 import org.mapstruct.Mapper;
+import org.mapstruct.Mapping;
 import org.mapstruct.ReportingPolicy;
 
 @Mapper(componentModel = "spring", unmappedSourcePolicy = ReportingPolicy.IGNORE)
 public interface UserMapper {
+  @Mapping(target = "password", ignore = true)
   AccountDto toDto(Account account);
 
   Account toDocument(AccountDto dto);
diff --git a/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/email/UserEmailService.java b/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/email/UserEmailService.java
index e83f641..f72c6f9 100644
--- a/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/email/UserEmailService.java
+++ b/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/email/UserEmailService.java
@@ -84,7 +84,7 @@ public class UserEmailService implements EmailService {
         .build();
   }
 
-  private static String generateVerifyEmailCode() {
+  public static String generateVerifyEmailCode() {
     byte[] randomBytes = new byte[16];
     SecureRandom random = new SecureRandom();
     random.nextBytes(randomBytes);
diff --git a/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/user/DefaultUserService.java b/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/user/DefaultUserService.java
index dcc920b..d32e699 100755
--- a/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/user/DefaultUserService.java
+++ b/user-svc/src/main/java/com/github/ngodat0103/usersvc/service/user/DefaultUserService.java
@@ -5,14 +5,16 @@ import static com.github.ngodat0103.usersvc.exception.Util.*;
 import com.github.ngodat0103.usersvc.dto.account.AccountDto;
 import com.github.ngodat0103.usersvc.dto.account.CredentialDto;
 import com.github.ngodat0103.usersvc.dto.mapper.UserMapper;
+import com.github.ngodat0103.usersvc.dto.mapper.UserMapperImpl;
 import com.github.ngodat0103.usersvc.exception.ConflictException;
 import com.github.ngodat0103.usersvc.exception.InvalidEmailCodeException;
 import com.github.ngodat0103.usersvc.persistence.document.Account;
 import com.github.ngodat0103.usersvc.persistence.repository.UserRepository;
 import com.github.ngodat0103.usersvc.service.auth.AuthService;
 import com.github.ngodat0103.usersvc.service.auth.JwtAuthService;
+import com.github.ngodat0103.usersvc.service.email.EmailService;
 import com.github.ngodat0103.usersvc.service.email.UserEmailService;
-import java.net.URI;
+
 import java.time.Instant;
 import java.time.LocalDateTime;
 import java.time.ZoneOffset;
@@ -24,11 +26,10 @@ import org.springframework.dao.DuplicateKeyException;
 import org.springframework.data.redis.core.ReactiveRedisTemplate;
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.server.reactive.ServerHttpRequest;
-import org.springframework.security.authentication.BadCredentialsException;
 import org.springframework.security.core.Authentication;
+import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
 import org.springframework.security.crypto.password.PasswordEncoder;
 import org.springframework.security.oauth2.core.endpoint.OAuth2AccessTokenResponse;
-import org.springframework.security.oauth2.jwt.JwtEncoder;
 import org.springframework.stereotype.Service;
 import reactor.core.publisher.Mono;
 import reactor.core.scheduler.Schedulers;
@@ -38,19 +39,15 @@ import reactor.core.scheduler.Schedulers;
 @Slf4j
 public class DefaultUserService implements UserService {
   private static final String EMAIL_ALREADY_VERIFIED = "Email already verified";
-  private static final String INVALID_EMAIL_OR_PASSWORD = "Invalid email or password";
-  private static final String USER_SVC = "user-svc";
-  private static final String EMAIL = "email";
+    private static final String EMAIL = "email";
   private static final String USER = "User";
-  private static final String IDX_EMAIL = "idx_email";
+  private final UserMapper userMapper = new UserMapperImpl();
+  private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
+    private final UserRepository userRepository;
 
-  private final UserRepository userRepository;
-  private final UserMapper userMapper;
-  private final PasswordEncoder passwordEncoder;
   private final ReactiveRedisTemplate<String, String> reactiveRedisTemplate;
-  private final UserEmailService userEmailService;
+  private final EmailService emailService;
   private final AuthService authService;
-  private final JwtAuthService jwtAuthService;
 
   @Override
   public Mono<AccountDto> getMe() {
@@ -65,7 +62,7 @@ public class DefaultUserService implements UserService {
 
   @Override
   public Mono<Void> logout(Authentication authentication) {
-    return jwtAuthService.logout(authentication);
+    return authService.logout(authentication);
   }
 
   @Override
@@ -94,7 +91,7 @@ public class DefaultUserService implements UserService {
         .flatMap(userRepository::findById)
         .flatMap(this::validateEmailVerificationStatus)
         .map(userMapper::toDto)
-        .flatMap(account -> userEmailService.resendEmailVerification(account, request.getHeaders()))
+        .flatMap(account -> emailService.resendEmailVerification(account, request.getHeaders()))
         .thenReturn("Email verification code resent");
   }
 
@@ -138,7 +135,9 @@ public class DefaultUserService implements UserService {
   }
 
   private void triggerEmailServiceAsync(AccountDto accountDto, HttpHeaders forwardedHeaders) {
-    userEmailService
+
+
+    emailService
         .emailNewUser(accountDto, forwardedHeaders)
         .subscribeOn(Schedulers.boundedElastic())
         .doOnSubscribe(s -> log.debug("Starting email task for user: {}", accountDto.getEmail()))
diff --git a/user-svc/src/main/resources/IT.yaml b/user-svc/src/main/resources/IT.yaml
index 5d638a4..7d46503 100644
--- a/user-svc/src/main/resources/IT.yaml
+++ b/user-svc/src/main/resources/IT.yaml
@@ -4,4 +4,21 @@ spring:
       on-profile: "IT"
 logging:
   level:
-    com.github.ngodat0103.usersvc.service: DEBUG
\ No newline at end of file
+    com.github.ngodat0103.usersvc.service: DEBUG
+minio:
+  access-key: "test"
+  secret-key: "test"
+jwk:
+  rsa: #Dev credential
+    key-value: |-
+      {
+      "p": "1j0tHGqgBAIMYgDVBm4NlkjNUNC4IXSDmXzt7HzDHg-kV9xY5CRam94DjfMKeMzhSnByV9iShzl5K13BLMZ95FYXIjP_tpPAppg67bth8nT7uEz0q628DA6-LPCjpEABjSl-f63tz8Bt9EcfRjOEaCtcpcG_XXDUQ4FthxU3UZLKjHdVxY8_NORWzruBeF8ycZ5FMTiEhtJeSr35ITLh7A7xc469kUXwhYvPkqgNHvkQjYZN7O4ojK2q4sJoPOw-ChLg3VyeFM9an1bsfkh3qy2-uO_SmZNG-ctlxkARAmSraa0raNEpYVqS1z2ucfY2V33i35tM4Ijr4OYVKaTciQ",
+      "kty": "RSA",
+      "q": "4-q4QeFFnImDryHoO-fDWgLaN2bGUgt7TGHu1WbSa91N06AT4w1PskaNR8lLCIFtu6HThAb2WtdhfZABebtDrEIw5l7zaetxO2El3pVY_gcvCFPunQxZQ4S39F3CIfOTaCTA1-DYxXNSk71Gq2ONYeioQlf2WEPveCGs93sY2iBpXDLBUl2rhu5p3DILHLmPg1yNfqRFhetNLlMFKPijLpJCsnE1b0An1hEWu_z2gOts-lJwuifesnuGqgswDOcloEtmf6_xor_zLq82fzH00ReYU3PyQCccPZ66upCg3z89qwqYCcQ2-JUspJwmUuvOvjdvSh3s3DYh67qlsrKT0w",
+      "d": "DJbcKlwf5dHaOLzHNEPgXNebotc-BpMsf5yjtZ7fU6L-GLXxvlsWREx2jCy18mjMfi3VycMQe-1DTMHf_kkPlcf90APYuGI9gCVwARRuw1aif6BCaLphN72yJyvf_kDGdLnL33mIIn2WRlseuVehg2TmVNxozrHBXyezCkwbcthBRRB4xd58cK2mBX7ivDM96AZnx5xOkL45xte1A3btvSeKS2e--f3BC1P_Gp0fdBynTm3KUvfhNwnTeqPhjaxASbD3_9TNBfgCmo9VByFpLIRKdnBL8jpzFtHtRlVRbWFukFucid0ofSechBFJ3u1Yh9jdI59zRLhyrFVaDEeAAfdRmzGXwg719qq_ryxI8lAbLF3z3N7oA8_Zu29QjMTanXK6VGQ22FMH7l95xaGmlVd_xYc6_kdPx6mgocljFrPewB6nkpyvFUABxn2j_BNnHYQgJK9AyjKDd0K9lLp12Ki10rWrSAu6XBIY8Q35gAQu7qXGiKbS1FIlEk8FWuQnheQXdVyAeYgBvQQZXHp8GJYvZ7MfKKgxgfslgmF69foyth-llYPJFEyNMMTubr67uYjWExQ-Qkg0VvGSPDvs8Ra2mzfcwvk4j5Z544ZA8SNUdITc2E1cakMU1OH0DdmCKKayW7Lgzzse8LgHZJCGaHXSO_RUgNse85ayuJYHRjE",
+      "e": "AQAB",
+      "qi": "Irdz8v2cNgQn4GJ-f7DJKqnbiJlgszzDDniwM6556vpGV21sx-jFfxzXxn12Ad100eYX8TjEb_hVpjRCggJywiTQ26F-Tpmn3YD3-g4lAf3L5YcrbZNEVXG0s66ZmncPtaTlgKHQtf-cRsWjvaMKDewx6Sxe6EOCnySaBC20WdZdPGXE28iTz75T_8DLaIcqh3Yq31pala3yWLrlvE7sRALaLQe1tGzhb3bvv1_rHEPvf8OgbEQMYl9Snh79IKulK0sN9q4iSla3XjtRh79ZYSEvss77c5Dm1InCi3qgw8OAc7tfh4iV1-TczLQcyEQhxT9NHKGID4olI5ooTD66HA",
+      "dp": "QGA_pvNPRAUNjYFsgbMeOBOGRouBWOQ3Cy8kG1TeGLFgk9oth9h4ta9_5-6pLeV6qTCi20zDswiNJX_VpUu71pob93Yil81MLYM-6eLNqtqGLTpKpy_ces8PTFe_BIMLNEzMqzcrZ6sOH0Ij3qdqWRb2jwRqKXzW-7XvoJC6f7OZU54kUuoZdx5KC3MCk5YfhU6mwgSWpiCentz4-IXep11SJoQ06GtYu_hoFkyTLMRwueYqklB6NNOWru71_aCLf-FuWnYTNnOcapbnF4dVFkX3soC2CtnbkQISggEMW2i-rVGQ4r0_LvbVewIY4ju21pGIU-LJtgrOvlTE9S-J6Q",
+      "dq": "efEDVHwqum34vqLtld-SbX5JMosSYKMz_NII7rRssLlfAnMLMNfWZBPLUzUnqA1XoKQcfu8ar8-8oWmC4JaIxolDkH4MzgbiNlrr4AMX8hH14AbIC86nk7BWm6_uRiwEGhxP8TCjykDBVbpXLSu-YTwRii116BOw9B1QZbi-uzXMKUAenuru8upsSRudRmkhl67VJYTOjbAvQzG3-QvOgwROGxrm8_bnWWkbOMlHOgK789JX7cGXLPdaPXBu7Phe8TxmQrroFaONgNTN24_m5Fgzb7MBUcGbInziex8Wc1tqqzCn19Hbd3SYxhmlh4gSvUL7kDQink94Jp9eOBXDcQ",
+      "n": "vrytHokAQM8PKmnaTcoGKHBk_Yvv2jHa4WQ7tb3kGK2LUNMlwYOO4ySQrXoFHc__d09SOAlJTkhGMMu1SGbtzVrb9XIMDBcnJFV3mORaVkpmwTa0pC1UdZa6tc7AOsDvQvMJAvuoGMzkhEE-G-A1_q7Ygv45gs4TCA2LX168GJodoSLjRxKe_casuGJ97IIWZ_sYmcxnbsaQvhmtItrEXpvF3FXqNKLPjgnPbaM1CmcPWkcF52R7RT60N0b4YO2Nf_dDI7vfkxaK6c2XoYhaTo_APtEhlkkbrGqwu1NBHxTtYoIiX4poQdDfNs9ym64jsqxG45GKebM5q18quh6D6SWLkYUOveFAcHJpYLeKqUpCuezg66W3_Aybh9CVuc0yx0iSDZE7_qbFx9vC1KHtfLJ0VqWYVHJLgGmK_bHw9rUd881z_mgHhpOytIuFFtT6FLs-FS2NF6gXgITSFa8nmEQQw0l40nqYK9_X7B-MQilWfWcieWe2pa_X_88XC3ikEx6APHRWdZ88GOXbDzoCvw3Q2z2D4qaVW5O1GIGuz9cQuI8WzYrOqCW6NqnQ41dI5eGfLPxtHZXrI_jwQ4ezX3aB0rl4SC9lDoCaaAs3Ws5kEOrQ2bbfgveaQlyw4geEWzvWYj7ysUm2Dl7_IYXVRnRhfJwhBXo2-mgOoJbGb-s"
+      }
\ No newline at end of file
diff --git a/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/ControllerIT.java b/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/ControllerIT.java
index cefbd30..a1ee1a5 100755
--- a/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/ControllerIT.java
+++ b/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/ControllerIT.java
@@ -1,352 +1,384 @@
-//package com.github.ngodat0103.usersvc.controller;
-//
-//import static org.junit.jupiter.api.Assertions.*;
-//
-//import com.fasterxml.jackson.core.JsonProcessingException;
-//import com.fasterxml.jackson.databind.MapperFeature;
-//import com.fasterxml.jackson.databind.ObjectMapper;
-//import com.github.javafaker.Faker;
-//import com.github.ngodat0103.usersvc.dto.account.AccountDto;
-//import com.github.ngodat0103.usersvc.dto.account.CredentialDto;
-//import com.github.ngodat0103.usersvc.dto.account.EmailDto;
-//import com.github.ngodat0103.usersvc.dto.mapper.UserMapper;
-//import com.github.ngodat0103.usersvc.dto.mapper.UserMapperImpl;
-//import com.github.ngodat0103.usersvc.dto.topic.Action;
-//import com.github.ngodat0103.usersvc.dto.topic.KeyTopic;
-//import com.github.ngodat0103.usersvc.dto.topic.ValueTopicRegisteredUser;
-//import com.github.ngodat0103.usersvc.exception.ConflictException;
-//import com.github.ngodat0103.usersvc.persistence.document.Account;
-//import com.github.ngodat0103.usersvc.persistence.repository.UserRepository;
-//import com.github.ngodat0103.usersvc.service.user.DefaultUserService;
-//import java.time.Duration;
-//import java.time.Instant;
-//import java.time.temporal.ChronoUnit;
-//import java.util.List;
-//import java.util.Map;
-//import lombok.extern.slf4j.Slf4j;
-//import org.apache.kafka.clients.consumer.KafkaConsumer;
-//import org.junit.jupiter.api.*;
-//import org.springframework.beans.factory.annotation.Autowired;
-//import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
-//import org.springframework.boot.test.context.SpringBootTest;
-//import org.springframework.context.annotation.Import;
-//import org.springframework.data.redis.core.ReactiveRedisTemplate;
-//import org.springframework.http.HttpStatus;
-//import org.springframework.http.ProblemDetail;
-//import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
-//import org.springframework.security.crypto.password.PasswordEncoder;
-//import org.springframework.security.oauth2.jwt.JwtClaimsSet;
-//import org.springframework.security.oauth2.jwt.JwtEncoder;
-//import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
-//import org.springframework.test.context.ActiveProfiles;
-//import org.springframework.test.context.DynamicPropertyRegistry;
-//import org.springframework.test.context.DynamicPropertySource;
-//import org.springframework.test.web.reactive.server.WebTestClient;
-//import org.springframework.util.Assert;
-//
-//@SpringBootTest
-//@AutoConfigureWebTestClient
-//@Import(MyTestConfiguration.class)
-//@ActiveProfiles("IT")
-//@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
-//@Slf4j
-//@Disabled(value = "Temporarily disabled due to the lack of implementation")
-//class ControllerIT {
-//  @Autowired private WebTestClient webTestClient;
-//  @Autowired private UserRepository userRepository;
-//  private final ObjectMapper objectMapper =
-//      new ObjectMapper().registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
-//  private static final String API_PATH = "/api/v1";
-//  private static final String USER_PATH = API_PATH + "/users";
-//  private static final String LOGIN_PATH = API_PATH + "/auth/login";
-//  private static final String AUTH_PATH = API_PATH + "/auth";
-//
-//  private final UserMapper userMapper = new UserMapperImpl();
-//  private AccountDto fakeAccountDto;
-//  private Account fakeAccount;
-//  @Autowired private KafkaConsumer<KeyTopic, ValueTopicRegisteredUser> consumer;
-//  @Autowired private JwtEncoder jwtEncoder;
-//  @Autowired private ReactiveRedisTemplate<String, String> reactiveRedisTemplate;
-//
-//  private static final List<String> TOPICS = List.of("user-business-logic");
-//
-//  @BeforeAll
-//  static void setUpAll() {
-//    ContainerConfig.startContainers();
-//  }
-//
-//  @AfterAll
-//  static void tearDownAll() {
-//    ContainerConfig.stopContainers();
-//  }
-//
-//  @DynamicPropertySource
-//  static void setProperties(DynamicPropertyRegistry registry) {
-//    registry.add("spring.kafka.bootstrap-servers", ContainerConfig::getKafkaBootstrapServers);
-//    registry.add("spring.data.mongodb.uri", ContainerConfig::getMongoDbUri);
-//    registry.add("spring.data.redis.port", ContainerConfig::getRedisPort);
-//  }
-//
-//  @BeforeEach
-//  void setUp() {
-//    this.objectMapper.configure(MapperFeature.USE_ANNOTATIONS, false);
-//    Faker faker = new Faker();
-//    String emailFake = faker.internet().emailAddress();
-//    String nickNameFake = faker.name().username();
-//    String passwordFake = faker.internet().password();
-//    fakeAccountDto = new AccountDto();
-//    fakeAccountDto.setEmail(emailFake);
-//    fakeAccountDto.setNickName(nickNameFake);
-//    fakeAccountDto.setPassword(passwordFake);
-//    this.fakeAccount = userMapper.toDocument(fakeAccountDto);
-//    this.fakeAccount.setAccountStatus(Account.AccountStatus.ACTIVE);
-//  }
-//
-//  @AfterEach
-//  void tearDown() {
-//    userRepository.deleteAll().block();
-//  }
-//
-//  @Test
-//  @Order(1)
-//  void createAccountWhenNotExists() {
-//    this.consumer.subscribe(TOPICS);
-//    webTestClient
-//        .post()
-//        .uri(USER_PATH)
-//        .header("Content-Type", "application/json")
-//        .bodyValue(fakeAccount)
-//        .exchange()
-//        .expectStatus()
-//        .isCreated();
-//
-//    var records = consumer.poll(Duration.ofSeconds(3));
-//    assertEquals(1, records.count()); // consume 2 messages from 2 topics: user-business-logic and
-//    // user-cdc
-//    var userSvcTopic = records.records(TOPICS.getFirst()).iterator().next();
-//    var topicRegisteredUser = userSvcTopic.value();
-//    Assertions.assertNotNull(topicRegisteredUser);
-//    Assertions.assertNotNull(topicRegisteredUser.getCreatedDate());
-//    Assertions.assertEquals(Action.INSERT, topicRegisteredUser.getAction());
-//    Map<String, Object> additionalProperties = topicRegisteredUser.getAdditionalProperties();
-//    Assertions.assertNotNull(additionalProperties);
-//    AccountDto accountDto = getAccountDtoFromTopic(topicRegisteredUser);
-//    Assertions.assertEquals(fakeAccountDto.getEmail(), accountDto.getEmail());
-//    Assertions.assertEquals(fakeAccountDto.getNickName(), accountDto.getNickName());
-//    Assertions.assertNull(accountDto.getPassword());
-//    Assertions.assertNotNull(accountDto.getCreatedDate());
-//    Assertions.assertNotNull(accountDto.getAccountId());
-//    Assertions.assertNotNull(accountDto.getLastUpdatedDate());
-//    EmailDto emailDto = getEmailDtoFromTopic(topicRegisteredUser);
-//    Assertions.assertEquals(fakeAccountDto.getEmail(), emailDto.getEmail());
-//    Assertions.assertEquals(accountDto.getAccountId(), emailDto.getAccountId());
-//    Assertions.assertNotNull(emailDto.getEmailVerificationCode());
-//    Assertions.assertNotNull(emailDto.getEmailVerificationEndpoint());
-//  }
-//
-//  private AccountDto getAccountDtoFromTopic(ValueTopicRegisteredUser valueTopicRegisteredUser) {
-//    Map<String, Object> additionalProperties = valueTopicRegisteredUser.getAdditionalProperties();
-//    return objectMapper.convertValue(additionalProperties.get("accountDto"), AccountDto.class);
-//  }
-//
-//  private EmailDto getEmailDtoFromTopic(ValueTopicRegisteredUser valueTopicRegisteredUser) {
-//    Map<String, Object> additionalProperties = valueTopicRegisteredUser.getAdditionalProperties();
-//    return objectMapper.convertValue(additionalProperties.get("emailDto"), EmailDto.class);
-//  }
-//
-//  @Test
-//  void createAccountWhenAlreadyExists() throws com.fasterxml.jackson.core.JsonProcessingException {
-//    userRepository.save(fakeAccount).block();
-//
-//    webTestClient
-//        .post()
-//        .uri(USER_PATH)
-//        .header("Content-Type", "application/json")
-//        .bodyValue(objectMapper.writeValueAsString(fakeAccountDto))
-//        .exchange()
-//        .expectStatus()
-//        .isEqualTo(HttpStatus.CONFLICT)
-//        .expectBody(ProblemDetail.class)
-//        .value(
-//            problemDetail -> {
-//              assertEquals(
-//                  ConflictException.Type.ALREADY_EXISTS.toString(), problemDetail.getTitle());
-//              assertEquals(
-//                  "https://problems-registry.smartbear.com/already-exists",
-//                  problemDetail.getType().toString());
-//              String expectedDetail =
-//                  "User with email: " + fakeAccountDto.getEmail() + " already exists";
-//              assertEquals(expectedDetail, problemDetail.getDetail());
-//            });
-//  }
-//
-//  @Test
-//  void givenBadCredential_whenLogin_thenReturn401() throws JsonProcessingException {
-//    CredentialDto credentialDto =
-//        CredentialDto.builder()
-//            .email(fakeAccountDto.getEmail())
-//            .password(fakeAccountDto.getPassword())
-//            .build();
-//    webTestClient
-//        .post()
-//        .uri(LOGIN_PATH)
-//        .header("Content-Type", "application/json")
-//        .bodyValue(objectMapper.writeValueAsString(credentialDto))
-//        .exchange()
-//        .expectStatus()
-//        .isUnauthorized()
-//        .expectBody(ProblemDetail.class)
-//        .value(
-//            problemDetail -> {
-//              assertEquals("Unauthorized", problemDetail.getTitle());
-//              assertEquals(
-//                  "https://problems-registry.smartbear.com/unauthorized",
-//                  problemDetail.getType().toString());
-//              String expectedDetail = "Invalid email or password";
-//              assertEquals(expectedDetail, problemDetail.getDetail());
-//            });
-//  }
-//
-//  @Test
-//  void givenValidCredential_whenLogin_thenReturnToken() throws JsonProcessingException {
-//    PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
-//    fakeAccount.setPassword(passwordEncoder.encode(fakeAccountDto.getPassword()));
-//    userRepository.save(fakeAccount).block();
-//    CredentialDto credentialDto =
-//        CredentialDto.builder()
-//            .email(fakeAccountDto.getEmail())
-//            .password(fakeAccountDto.getPassword())
-//            .build();
-//    webTestClient
-//        .post()
-//        .uri(LOGIN_PATH)
-//        .header("Content-Type", "application/json")
-//        .bodyValue(objectMapper.writeValueAsString(credentialDto))
-//        .exchange()
-//        .expectStatus()
-//        .isOk()
-//        .expectBody()
-//        .jsonPath("$.accessToken.tokenValue")
-//        .isNotEmpty()
-//        .jsonPath("$.accessToken.tokenType.value")
-//        .isEqualTo("Bearer")
-//        .jsonPath("$.accessToken.expiresAt")
-//        .isNotEmpty()
-//        .jsonPath("$.accessToken.issuedAt")
-//        .isNotEmpty();
-//  }
-//
-//  @Test
-//  void GivenValidToken_whenGetMe_thenReturnAccount() {
-//    fakeAccount = userRepository.save(fakeAccount).block();
-//    String accessToken = createTemporaryAccessToken(fakeAccount);
-//    webTestClient
-//        .get()
-//        .uri(USER_PATH + "/me")
-//        .header("Authorization", "Bearer " + accessToken)
-//        .exchange()
-//        .expectStatus()
-//        .isOk()
-//        .expectBody()
-//        .jsonPath("$.accountId")
-//        .isNotEmpty()
-//        .jsonPath("$.nickName")
-//        .isEqualTo(fakeAccount.getNickName())
-//        .jsonPath("$.email")
-//        .isEqualTo(fakeAccount.getEmail())
-//        .jsonPath("$.emailVerified")
-//        .isEqualTo(fakeAccount.isEmailVerified());
-//  }
-//
-//  @Test
-//  void givenAlreadyVerified_whenResendEmail_thenReturn409() {
-//    fakeAccount.setEmailVerified(true);
-//    fakeAccount = userRepository.save(fakeAccount).block();
-//    String accessToken = createTemporaryAccessToken(fakeAccount);
-//    webTestClient
-//        .get()
-//        .uri(AUTH_PATH + "/resend-email")
-//        .header("Authorization", "Bearer " + accessToken)
-//        .exchange()
-//        .expectStatus()
-//        .isEqualTo(HttpStatus.CONFLICT)
-//        .expectBody(ProblemDetail.class)
-//        .value(
-//            problemDetail -> {
-//              assertEquals(
-//                  ConflictException.Type.ALREADY_VERIFIED.toString(), problemDetail.getTitle());
-//              assertEquals(
-//                  "https://problems-registry.smartbear.com/already-exists",
-//                  problemDetail.getType().toString());
-//              String expectedDetail = "Email already verified";
-//              assertEquals(expectedDetail, problemDetail.getDetail());
-//            });
-//  }
-//
-//  @Test
-//  @Order(2)
-//  void givenNotVerified_whenResendEmail_thenReturn202() {
-//    this.consumer.commitSync();
-//    fakeAccount.setEmailVerified(false);
-//    fakeAccount = userRepository.save(fakeAccount).block();
-//    String accessToken = createTemporaryAccessToken(fakeAccount);
-//    webTestClient
-//        .get()
-//        .uri(AUTH_PATH + "/resend-email")
-//        .header("Authorization", "Bearer " + accessToken)
-//        .exchange()
-//        .expectStatus()
-//        .isEqualTo(HttpStatus.ACCEPTED);
-//    var records = consumer.poll(Duration.ofSeconds(3));
-//    assertEquals(1, records.count());
-//    var recordKafka = records.records(TOPICS.getFirst());
-//    var topicRegisteredUser = recordKafka.iterator().next().value();
-//    Assertions.assertNotNull(topicRegisteredUser);
-//    Assertions.assertEquals(Action.RESEND_EMAIL_VERIFICATION, topicRegisteredUser.getAction());
-//    EmailDto emailDto = getEmailDtoFromTopic(topicRegisteredUser);
-//    Assertions.assertNotNull(emailDto);
-//    Assertions.assertEquals(fakeAccount.getAccountId(), emailDto.getAccountId());
-//    Assertions.assertEquals(fakeAccount.getEmail(), emailDto.getEmail());
-//    Assertions.assertNotNull(emailDto.getEmailVerificationCode());
-//    Assertions.assertNotNull(emailDto.getEmailVerificationEndpoint());
-//    consumer.commitSync();
-//  }
-//
-//  @Test
-//  void givenValidCode_whenVerifyEmail_thenReturn200() {
-//    fakeAccount.setEmailVerified(false);
-//    fakeAccount = userRepository.save(fakeAccount).block();
-//
-//    String randomCode = DefaultUserService.generateVerifyEmailCode();
-//    reactiveRedisTemplate.opsForValue().set(randomCode, fakeAccount.getAccountId()).block();
-//    String accessToken = createTemporaryAccessToken(fakeAccount);
-//    webTestClient
-//        .get()
-//        .uri(
-//            uriBuilder ->
-//                uriBuilder.path(AUTH_PATH + "/verify-email").queryParam("code", randomCode).build())
-//        .header("Authorization", "Bearer " + accessToken)
-//        .exchange()
-//        .expectStatus()
-//        .isOk()
-//        .expectBody(String.class)
-//        .value(
-//            message -> {
-//              assertEquals("Email verified", message);
-//            });
-//  }
-//
-//  private String createTemporaryAccessToken(Account account) {
-//    Assert.notNull(account, "Account must not be null");
-//    JwtClaimsSet jwtClaimsSet =
-//        JwtClaimsSet.builder()
-//            .subject(account.getAccountId())
-//            .issuer("user-svc")
-//            .issuedAt(Instant.now())
-//            .expiresAt(Instant.now().plus(1, ChronoUnit.MINUTES))
-//            .build();
-//    JwtEncoderParameters jwtEncoderParameters = JwtEncoderParameters.from(jwtClaimsSet);
-//
-//    return jwtEncoder.encode(jwtEncoderParameters).getTokenValue();
-//  }
-//}
+package com.github.ngodat0103.usersvc.controller;
+import static org.junit.jupiter.api.Assertions.*;
+import com.github.javafaker.Faker;
+import com.github.ngodat0103.usersvc.dto.account.AccountDto;
+import com.github.ngodat0103.usersvc.dto.account.CredentialDto;
+import com.github.ngodat0103.usersvc.dto.mapper.UserMapper;
+import com.github.ngodat0103.usersvc.dto.mapper.UserMapperImpl;
+import com.github.ngodat0103.usersvc.dto.topic.Action;
+import com.github.ngodat0103.usersvc.exception.ConflictException;
+import com.github.ngodat0103.usersvc.persistence.document.Account;
+import com.github.ngodat0103.usersvc.persistence.repository.UserRepository;
+import com.github.ngodat0103.usersvc.service.email.UserEmailService;
+import com.jayway.jsonpath.JsonPath;
+import com.redis.testcontainers.RedisContainer;
+import java.time.Duration;
+import java.time.Instant;
+import java.time.temporal.ChronoUnit;
+import java.util.List;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.junit.jupiter.api.*;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.data.redis.core.ReactiveRedisTemplate;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ProblemDetail;
+import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
+import org.springframework.security.crypto.password.PasswordEncoder;
+import org.springframework.security.oauth2.jwt.JwtClaimsSet;
+import org.springframework.security.oauth2.jwt.JwtEncoder;
+import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
+import org.springframework.test.context.ActiveProfiles;
+import org.springframework.test.context.DynamicPropertyRegistry;
+import org.springframework.test.context.DynamicPropertySource;
+import org.springframework.test.web.reactive.server.WebTestClient;
+import org.springframework.util.Assert;
+import org.testcontainers.containers.MinIOContainer;
+import org.testcontainers.containers.MongoDBContainer;
+import org.testcontainers.kafka.ConfluentKafkaContainer;
+import org.testcontainers.shaded.com.fasterxml.jackson.core.JsonProcessingException;
+import org.testcontainers.shaded.com.fasterxml.jackson.databind.MapperFeature;
+import org.testcontainers.shaded.com.fasterxml.jackson.databind.ObjectMapper;
+import org.testcontainers.utility.DockerImageName;
+
+@SpringBootTest
+@AutoConfigureWebTestClient
+@ActiveProfiles("IT")
+@Slf4j
+class ControllerIT {
+    @Autowired private WebTestClient webTestClient;
+    @Autowired private UserRepository userRepository;
+    private final ObjectMapper objectMapper = new ObjectMapper();
+    private static final String API_PATH = "/api/v1";
+    private static final String USER_PATH = API_PATH + "/users";
+    private static final String LOGIN_PATH = API_PATH + "/auth/login";
+    private static final String AUTH_PATH = API_PATH + "/auth";
+    private static final String MONGODB_DOCKER_IMAGE =
+            "mongodb/mongodb-community-server:7.0.6-ubuntu2204-20241117T082517Z";
+    private static final MongoDBContainer mongoDBContainer =
+            new MongoDBContainer(MONGODB_DOCKER_IMAGE);
+
+    private static final RedisContainer redisContainer =
+            new RedisContainer(DockerImageName.parse("redis:alpine3.20"));
+
+    private static final String KAFKA_DOCKER_IMAGE = "confluentinc/cp-kafka:7.4.6";
+
+    private static final ConfluentKafkaContainer kafkaContainer =
+            new ConfluentKafkaContainer(KAFKA_DOCKER_IMAGE);
+
+    private static final MinIOContainer minioContainer = new MinIOContainer(DockerImageName.parse("minio/minio:RELEASE.2023-09-04T19-57-37Z"));
+    private final UserMapper userMapper = new UserMapperImpl();
+    private AccountDto fakeAccountDto;
+    private Account fakeAccount;
+    private KafkaConsumer<String, String> consumer;
+    @Autowired
+    private JwtEncoder jwtEncoder;
+    @Autowired
+    private ReactiveRedisTemplate<String, String> reactiveRedisTemplate;
+
+    private static final List<String> TOPICS = List.of("user-email");
+
+    @BeforeAll
+    static void setUpAll() {
+        mongoDBContainer.start();
+        kafkaContainer.start();
+        redisContainer.start();
+        minioContainer.start();
+    }
+
+    @AfterAll
+    static void tearDownAll() {
+        mongoDBContainer.stop();
+        kafkaContainer.stop();
+        redisContainer.stop();
+        minioContainer.stop();
+    }
+
+    @DynamicPropertySource
+    static void setProperties(DynamicPropertyRegistry registry) {
+        registry.add("spring.kafka.bootstrap-servers", kafkaContainer::getBootstrapServers);
+        registry.add("spring.data.mongodb.uri", mongoDBContainer::getReplicaSetUrl);
+        registry.add("spring.data.redis.port", redisContainer::getRedisPort);
+        registry.add("minio.url", minioContainer::getS3URL);
+        registry.add("minio.access-key", minioContainer::getUserName);
+        registry.add("minio.secret-key", minioContainer::getPassword);
+    }
+
+    @BeforeEach
+    void setUp() {
+        this.objectMapper.configure(MapperFeature.USE_ANNOTATIONS, false);
+        Faker faker = new Faker();
+        String emailFake = faker.internet().emailAddress();
+        String nickNameFake = faker.name().username();
+        String passwordFake = faker.internet().password();
+        this.fakeAccountDto =
+
+                AccountDto.builder().email(emailFake).nickName(nickNameFake).password(passwordFake).build();
+        this.fakeAccount = userMapper.toDocument(fakeAccountDto);
+        this.fakeAccount.setAccountStatus(Account.AccountStatus.ACTIVE);
+        this.consumer = new KafkaConsumer<>(getConsumerProps());
+        this.consumer.subscribe(TOPICS);
+    }
+
+    @AfterEach
+    void tearDown() {
+        userRepository.deleteAll().block();
+        consumer.close();
+    }
+
+    @Test
+    void createAccountWhenNotExists() {
+        webTestClient
+                .post()
+                .uri(USER_PATH)
+                .header("Content-Type", "application/json")
+                .bodyValue(fakeAccount)
+                .exchange()
+                .expectStatus()
+                .isCreated();
+
+        var records = consumer.poll(Duration.ofSeconds(3));
+        assertEquals(1, records.count());
+        var recordKafka = records.iterator().next();
+        var value = recordKafka.value();
+        assertNotNull(JsonPath.read(value, "$.createdDate"));
+        assertEquals(Action.INSERT.toString(), JsonPath.read(value,
+                "$.action"));
+
+//        // accountDto assertions
+//        assertNotNull(JsonPath.read(value, "$.additionalProperties.accountDto.accountId"));
+//        assertEquals(
+//                fakeAccount.getNickName(),
+//                JsonPath.read(value, "$.additionalProperties.accountDto.nickName"));
+//        assertEquals(
+//                fakeAccount.getEmail(), JsonPath.read(value, "$.additionalProperties.accountDto.email"));
+//        assertNull(JsonPath.read(value, "$.additionalProperties.accountDto.zoneInfo"));
+//        assertNull(JsonPath.read(value, "$.additionalProperties.accountDto.pictureUrl"));
+//        assertNull(JsonPath.read(value, "$.additionalProperties.accountDto.locale"));
+//        assertEquals(
+//                Boolean.FALSE, JsonPath.read(value, "$.additionalProperties.accountDto.emailVerified"));
+//        assertNotNull(JsonPath.read(value, "$.additionalProperties.accountDto.lastUpdatedDate"));
+//        assertNotNull(JsonPath.read(value, "$.additionalProperties.accountDto.createdDate"));
+
+        // emailDto assertions
+        assertNotNull(JsonPath.read(value, "$.additionalProperties.emailDto.accountId"));
+        assertNotNull(JsonPath.read(value, "$.additionalProperties.emailDto.emailVerificationCode"));
+        assertNotNull(
+                JsonPath.read(value, "$.additionalProperties.emailDto.emailVerificationEndpoint"));
+        assertEquals(
+                fakeAccount.getEmail(), JsonPath.read(value, "$.additionalProperties.emailDto.email"));
+    }
+
+    @Test
+    void createAccountWhenAlreadyExists() throws JsonProcessingException {
+        userRepository.save(fakeAccount).block();
+
+        webTestClient
+                .post()
+                .uri(USER_PATH)
+                .header("Content-Type", "application/json")
+                .bodyValue(objectMapper.writeValueAsString(fakeAccountDto))
+                .exchange()
+                .expectStatus()
+                .isEqualTo(HttpStatus.CONFLICT)
+                .expectBody(ProblemDetail.class)
+                .value(
+                        problemDetail -> {
+                            assertEquals(
+                                    ConflictException.Type.ALREADY_EXISTS.toString(), problemDetail.getTitle());
+                            assertEquals(
+                                    "https://problems-registry.smartbear.com/already-exists",
+                                    problemDetail.getType().toString());
+                            String expectedDetail =
+                                    "User with email: " + fakeAccountDto.getEmail() + " already exists";
+                            assertEquals(expectedDetail, problemDetail.getDetail());
+                        });
+    }
+
+    @Test
+    void givenBadCredential_whenLogin_thenReturn401() throws JsonProcessingException {
+        CredentialDto credentialDto =
+                CredentialDto.builder()
+                        .email(fakeAccountDto.getEmail())
+                        .password(fakeAccountDto.getPassword())
+                        .build();
+        webTestClient
+                .post()
+                .uri(LOGIN_PATH)
+                .header("Content-Type", "application/json")
+                .bodyValue(objectMapper.writeValueAsString(credentialDto))
+                .exchange()
+                .expectStatus()
+                .isUnauthorized()
+                .expectBody(ProblemDetail.class)
+                .value(
+                        problemDetail -> {
+                            assertEquals("Unauthorized", problemDetail.getTitle());
+                            assertEquals(
+                                    "https://problems-registry.smartbear.com/unauthorized",
+                                    problemDetail.getType().toString());
+                            String expectedDetail = "Invalid email or password";
+                            assertEquals(expectedDetail, problemDetail.getDetail());
+                        });
+    }
+
+    @Test
+    void givenValidCredential_whenLogin_thenReturnToken() throws JsonProcessingException {
+        PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
+        fakeAccount.setPassword(passwordEncoder.encode(fakeAccountDto.getPassword()));
+        userRepository.save(fakeAccount).block();
+        CredentialDto credentialDto =
+                CredentialDto.builder()
+                        .email(fakeAccountDto.getEmail())
+                        .password(fakeAccountDto.getPassword())
+                        .build();
+        webTestClient
+                .post()
+                .uri(LOGIN_PATH)
+                .header("Content-Type", "application/json")
+                .bodyValue(objectMapper.writeValueAsString(credentialDto))
+                .exchange()
+                .expectStatus()
+                .isOk()
+                .expectBody()
+                .jsonPath("$.accessToken.tokenValue")
+                .isNotEmpty()
+                .jsonPath("$.accessToken.tokenType.value")
+                .isEqualTo("Bearer")
+                .jsonPath("$.accessToken.expiresAt")
+                .isNotEmpty()
+                .jsonPath("$.accessToken.issuedAt")
+                .isNotEmpty();
+    }
+
+    @Test
+    void GivenValidToken_whenGetMe_thenReturnAccount() {
+        fakeAccount = userRepository.save(fakeAccount).block();
+        String accessToken = createTemporaryAccessToken(fakeAccount);
+        webTestClient
+                .get()
+                .uri(USER_PATH + "/me")
+                .header("Authorization", "Bearer " + accessToken)
+                .exchange()
+                .expectStatus()
+                .isOk()
+                .expectBody()
+                .jsonPath("$.accountId")
+                .isNotEmpty()
+                .jsonPath("$.nickName")
+                .isEqualTo(fakeAccount.getNickName())
+                .jsonPath("$.email")
+                .isEqualTo(fakeAccount.getEmail())
+                .jsonPath("$.emailVerified")
+                .isEqualTo(fakeAccount.isEmailVerified());
+    }
+
+    @Test
+    void givenAlreadyVerified_whenResendEmail_thenReturn409() {
+        fakeAccount.setEmailVerified(true);
+        fakeAccount = userRepository.save(fakeAccount).block();
+        String accessToken = createTemporaryAccessToken(fakeAccount);
+        webTestClient
+                .get()
+                .uri(AUTH_PATH + "/resend-email")
+                .header("Authorization", "Bearer " + accessToken)
+                .exchange()
+                .expectStatus()
+                .isEqualTo(HttpStatus.CONFLICT)
+                .expectBody(ProblemDetail.class)
+                .value(
+                        problemDetail -> {
+                            assertEquals(
+                                    ConflictException.Type.ALREADY_VERIFIED.toString(), problemDetail.getTitle());
+                            assertEquals(
+                                    "https://problems-registry.smartbear.com/already-exists",
+                                    problemDetail.getType().toString());
+                            String expectedDetail = "Email already verified";
+                            assertEquals(expectedDetail, problemDetail.getDetail());
+                        });
+    }
+
+    @Test
+    void givenNotVerified_whenResendEmail_thenReturn202() {
+        fakeAccount.setEmailVerified(false);
+        fakeAccount = userRepository.save(fakeAccount).block();
+        String accessToken = createTemporaryAccessToken(fakeAccount);
+        webTestClient
+                .get()
+                .uri(AUTH_PATH + "/resend-email")
+                .header("Authorization", "Bearer " + accessToken)
+                .exchange()
+                .expectStatus()
+                .isEqualTo(HttpStatus.ACCEPTED);
+        var records = consumer.poll(Duration.ofSeconds(5));
+        assertEquals(1, records.count());
+        var recordKafka = records.iterator().next();
+        var value = recordKafka.value();
+        log.debug(value);
+        String accountId = JsonPath.read(value, "$.additionalProperties.emailDto.accountId");
+        String email = JsonPath.read(value, "$.additionalProperties.emailDto.email");
+        assertEquals(fakeAccountDto.getEmail(), email);
+        Assertions.assertNotNull(accountId);
+        assertEquals(
+                Action.RESEND_EMAIL_VERIFICATION.toString(),
+                JsonPath.read(value, "$.action"));
+    }
+
+    @Test
+    void givenValidCode_whenVerifyEmail_thenReturn200() {
+        fakeAccount.setEmailVerified(false);
+        fakeAccount = userRepository.save(fakeAccount).block();
+
+        String randomCode = UserEmailService.generateVerifyEmailCode();
+        reactiveRedisTemplate.opsForValue().set(randomCode, fakeAccount.getAccountId()).block();
+        String accessToken = createTemporaryAccessToken(fakeAccount);
+        webTestClient
+                .get()
+                .uri(
+                        uriBuilder ->
+                                uriBuilder.path(AUTH_PATH + "/verify-email").queryParam("code",
+                                        randomCode).build())
+                .header("Authorization", "Bearer " + accessToken)
+                .exchange()
+                .expectStatus()
+                .isOk()
+                .expectBody(String.class)
+                .value(
+                        message -> {
+                            assertEquals("Email verified", message);
+                        });
+    }
+
+    private String createTemporaryAccessToken(Account account) {
+        Assert.notNull(account, "Account must not be null");
+        JwtClaimsSet jwtClaimsSet =
+                JwtClaimsSet.builder()
+                        .subject(account.getAccountId())
+                        .issuer("user-svc")
+                        .issuedAt(Instant.now())
+                        .expiresAt(Instant.now().plus(1, ChronoUnit.MINUTES))
+                        .build();
+        JwtEncoderParameters jwtEncoderParameters = JwtEncoderParameters.from(jwtClaimsSet);
+
+        return jwtEncoder.encode(jwtEncoderParameters).getTokenValue();
+    }
+
+    private Map<String, Object> getConsumerProps() {
+        return Map.of(
+                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,
+                "earliest",
+                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,
+                kafkaContainer.getBootstrapServers(),
+                ConsumerConfig.GROUP_ID_CONFIG,
+                "test-group",
+                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,
+                StringDeserializer.class,
+                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,
+                StringDeserializer.class);
+    }
+}
\ No newline at end of file
diff --git a/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/service/defaultUserServiceTest.java b/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/service/defaultUserServiceTest.java
index 03b54dc..b7f059d 100644
--- a/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/service/defaultUserServiceTest.java
+++ b/user-svc/src/test/java/com/github/ngodat0103/usersvc/controller/service/defaultUserServiceTest.java
@@ -1,72 +1,116 @@
-//package com.github.ngodat0103.usersvc.controller.service;
-//
-//import static org.mockito.BDDMockito.*;
-//import static org.mockito.Mockito.when;
-//
-//import com.github.javafaker.Faker;
-//import com.github.ngodat0103.usersvc.dto.account.AccountDto;
-//import com.github.ngodat0103.usersvc.dto.mapper.UserMapper;
-//import com.github.ngodat0103.usersvc.dto.mapper.UserMapperImpl;
-//import com.github.ngodat0103.usersvc.persistence.document.Account;
-//import com.github.ngodat0103.usersvc.persistence.repository.UserRepository;
-//import com.github.ngodat0103.usersvc.service.user.DefaultUserService;
-//import org.junit.jupiter.api.BeforeEach;
-//import org.junit.jupiter.api.Test;
-//import org.junit.jupiter.api.extension.ExtendWith;
-//import org.mockito.Mock;
-//import org.springframework.http.HttpHeaders;
-//import org.springframework.http.server.reactive.ServerHttpRequest;
-//import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
-//import org.springframework.security.crypto.password.PasswordEncoder;
-//import org.springframework.test.context.junit.jupiter.SpringExtension;
-//import reactor.core.publisher.Mono;
-//import reactor.test.StepVerifier;
-//
-//@ExtendWith(SpringExtension.class)
-//public class defaultUserServiceTest {
-//  private final UserMapper userMapper = new UserMapperImpl();
-//
-//  private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
-//
-//  @Mock private UserRepository userRepository;
-//
-//  private DefaultUserService defaultUserService; // Actual service class being tested
-//
-//  @Mock private ServerHttpRequest serverHttpRequest;
-//
-//  @Mock private HttpHeaders httpHeaders;
-//
-//  private AccountDto fakeaccountDto;
-//  private Account fakeAccount;
-//
-//  @BeforeEach
-//  void setUp() {
-//    Faker faker = new Faker();
-//    fakeaccountDto = new AccountDto();
-//    fakeaccountDto.setEmail(faker.internet().safeEmailAddress());
-//    fakeaccountDto.setPassword(faker.internet().password(8, 20));
-//    fakeaccountDto.setNickName(faker.name().fullName());
-//    fakeAccount =
-//        Account.builder()
-//            .email(fakeaccountDto.getEmail())
-//            .password(fakeaccountDto.getPassword())
-//            .nickName(fakeaccountDto.getNickName())
-//            .build();
-//
-//    // Mock ServerHttpRequest headers
-//    when(serverHttpRequest.getHeaders()).thenReturn(httpHeaders);
-//
-//    this.defaultUserService = new DefaultUserService(userRepository, userMapper, passwordEncoder);
-//  }
-//
-//  @Test
-//  void givenNotExistsWhenCreateAccountThenReturnSuccessful() {
-//    given(userRepository.save(any(Account.class))).willReturn(Mono.just(fakeAccount));
-//    StepVerifier.create(defaultUserService.create(fakeaccountDto, serverHttpRequest))
-//        .expectNext(fakeaccountDto)
-//        .verifyComplete();
-//  }
-//
-//  @Test
-//  void testCreateAccountErrorHandling() {}
-//}
+package com.github.ngodat0103.usersvc.controller.service;
+
+import static org.mockito.BDDMockito.*;
+import static org.mockito.Mockito.when;
+
+import com.github.javafaker.Faker;
+import com.github.javafaker.Internet;
+import com.github.ngodat0103.usersvc.dto.account.AccountDto;
+import com.github.ngodat0103.usersvc.dto.mapper.UserMapper;
+import com.github.ngodat0103.usersvc.dto.mapper.UserMapperImpl;
+import com.github.ngodat0103.usersvc.persistence.document.Account;
+import com.github.ngodat0103.usersvc.persistence.repository.UserRepository;
+import com.github.ngodat0103.usersvc.service.email.EmailService;
+import com.github.ngodat0103.usersvc.service.email.UserEmailService;
+import com.github.ngodat0103.usersvc.service.user.DefaultUserService;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.springframework.data.redis.core.ReactiveRedisTemplate;
+import org.springframework.http.HttpHeaders;
+import org.springframework.http.server.reactive.ServerHttpRequest;
+import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
+import org.springframework.security.crypto.password.PasswordEncoder;
+import org.springframework.test.context.junit.jupiter.SpringExtension;
+import reactor.core.publisher.Mono;
+import reactor.test.StepVerifier;
+
+import java.time.Instant;
+
+@ExtendWith(SpringExtension.class)
+public class defaultUserServiceTest {
+
+  @Mock private UserRepository userRepository;
+
+
+  @Mock private EmailService emailService;
+
+  @InjectMocks
+  private DefaultUserService defaultUserService;
+
+  @Mock private ServerHttpRequest serverHttpRequest;
+
+  @Mock private HttpHeaders httpHeaders;
+  @Mock private ReactiveRedisTemplate<String, String> reactiveRedisTemplate;
+
+  private AccountDto fakeaccountDto;
+  private Account fakeAccount;
+
+  @BeforeEach
+  void setUp() {
+    Faker faker = new Faker();
+    fakeaccountDto = AccountDto.builder()
+        .email(faker.internet().emailAddress())
+        .password(faker.internet().password())
+        .nickName(faker.name().username())
+        .build();
+    fakeAccount =
+        Account.builder()
+            .email(fakeaccountDto.getEmail())
+            .password(fakeaccountDto.getPassword())
+            .nickName(fakeaccountDto.getNickName())
+            .build();
+
+    // Mock ServerHttpRequest headers
+    this.httpHeaders = HttpHeaders.readOnlyHttpHeaders(
+        new HttpHeaders() {
+          {
+              Internet internet = faker.internet();
+            add("X-Forwarded-Proto", internet.domainName());
+            add("X-Forwarded-Host", internet.domainName());
+            add("X-Forwarded-For", internet.ipV4Address());
+          }
+        });
+//    when(httpHeaders.getFirst("X-Forwarded-Scheme")).thenReturn("http");
+  }
+
+  @Test
+  void givenNotExistsWhenCreateAccountThenReturnSuccessful() {
+      Mono<Void> voidMono = Mono.empty();
+      when(emailService.emailNewUser(any(AccountDto.class), any(HttpHeaders.class)))
+              .thenReturn(Mono.empty());
+     Account mockResponse = Account.builder()
+        .email(fakeaccountDto.getEmail())
+        .password(fakeaccountDto.getPassword())
+        .nickName(fakeaccountDto.getNickName())
+             .emailVerified(false)
+             .accountId("123219783129873")
+        .build();
+      Instant now = Instant.now();
+     mockResponse.setCreatedDate(now);
+        mockResponse.setLastUpdatedDate(now);
+    given(userRepository.save(any(Account.class))).willReturn(Mono.just(mockResponse));
+    given(serverHttpRequest.getHeaders()).willReturn(this.httpHeaders);
+    StepVerifier.create(defaultUserService.create(fakeaccountDto, serverHttpRequest))
+        .expectNextMatches(
+            responseAccountDto -> {
+                Assertions.assertNotNull(responseAccountDto.getAccountId());
+                Assertions.assertNotNull(responseAccountDto.getCreatedDate());
+                Assertions.assertNotNull(responseAccountDto.getLastUpdatedDate());
+                Assertions.assertEquals(fakeaccountDto.getEmail(), responseAccountDto.getEmail());
+                Assertions.assertEquals(fakeaccountDto.getNickName(), responseAccountDto.getNickName());
+                Assertions.assertNull(responseAccountDto.getPassword());
+              return true;
+            })
+        .verifyComplete();
+  }
+
+  @Test
+  void testCreateAccountErrorHandling() {
+
+  }
+}
